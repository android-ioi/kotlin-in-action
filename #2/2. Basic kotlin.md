# 2장. 코틀린 기초
## 함수
- 함수를 선언할 때 fun 키워드를 사용하고, 파라미터 이름 뒤에 타입을 쓴다.
```kt
fun someMethod(param: Int) : String {
    return "HelloWorld! (param=$param)"
}
```

- 함수를 최상위 수준에 정의할 수 있다. (자바와 다르게 클래스 내부에 있을 필요가 없다.
    
    -> (경준) 다만, 최상위에 선언할 경우, 다른 클래스에서 import할 경우 java의 static import와 같이 추후 코드를 분석할 때, 혼동이 있을 수 있어, 남발하면 좋지 않다고 생각 (익스텐션에 사용해야 할 듯)

    ```kt
    package com.ncsoft.example.utils

    fun someMethod() : String {
        return "Hello, World!"
    }
    ```
    ```kt
    package com.ncsoft.example

    import com.ncsoft.example.utils.someMethod // 함수 임포트

    fun main(args: Array<String>) {
        println(someMethod()) // 코드 스니핏만 보면 someMethod가 어느 클래스에 있는 메소드인지 알기 어렵다.
    }
    ```
### 문(statement)과 식(expression)
* https://blog.leocat.kr/notes/2019/12/29/kotlin-statement-and-expression
* https://dev-kimji1.medium.com/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B8%B0%EC%B4%88-814c9b2bc82a

자바의 if-else는 문(statement)이고, 코틀린의 if-else는 식(expression)이다.

> 식(expression)은 값을 만들어내고, 문(statement)은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상의 요소로 존재하며 아무런 값을 만들어내지 않는다.

자바에서는 모든 제어 구조가 문인 반면, 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다.

kotlin의 if 역시 식(expression)이다.
```kt
fun max(a: Int, b: Int) = if(a > b) a else b
```
#### when(switch)
when 역시 값을 리턴하는 `식`이다. (switch문으로 컴파일 된다.)
```kt
fun foo(value: Int) = 
    when(value) {
        1 -> "One"
        2 -> "Two"
        3 -> "Three"
        else -> "Over four or negative."
    }
```
foo 함수의 경우, 타입 추론으로 리턴 값이 String이 된다. 식이 본문인 경우에만 타입 추론이 되고, 블록이 본문이면 리턴 타입을 지정해야 한다.
```kt
fun foo(value: Int) : String {
    return when (value) {
        1 -> "One"
        2 -> "Two"
        3 -> "Three"
        else -> "Over four or negative."
    }
}
```
> 이렇게 설계한 이유는, 아주 긴 함수에서는 명시적으로 return을 해주는 것이 더 쉽게 알아볼 수 있기 때문이다.

## 변수
```kt
val value1 = "Hello, World"
val value2 = 100
val value3 : Int = 100
val value4 = 3.14f
val value5 = 7.5e6 // 7.5 * 10^6 = 7500000.0
```

- val (value) : 변경 불가능(immutable), 자바의 final과 같은 키워드
- var (variable) : 변경 가능 (mutable)

기본적으로 val으로 선언하고, 필요 시 var을 사용하도록 하자.
> 이는 부수 효과(side-effect)가 없는 순수 함수를 일급 객체로 사용하는 순수 함수형 프로그래밍을 구현하기 위함이다.

## 문자열 템플릿
```kt
val name = "John"
val hello = "Hello, $name"
```
```kt
val args = arrayOf(0, 1, 2, 3)
val hello = "Hello, ${args[0]}"
println("args: ${if (args.isEmpty()) "empty" else args[0] }")
```

## 클래스와 프로퍼티
### 클래스
```kt
class Person(val name: String)
```
getter, setter의 보일러 플레이트 코드가 필요 없다.
### 프로퍼티
프로퍼티를 기본으로 제공, 자바의 필드와 접근자를 대신함
```kt
class Person(
    val name: String,       // (val) getter
    var isMarried: Boolean  // (var) getter, setter
)
```
특히, 프로퍼티를 자바에서 접근할 경우 getter, setter의 이름에는 일정 규칙과 예외가 있다.
```java
Person person = new Person("John", false);
String name = person.getName();
boolean isMarried = person.isMarried();
person.setMarried(true);
```
지원(backing) 필드: 프로퍼티의 값을 저장하기 위한 비공개 필드
* https://zerodice0.tistory.com/112
```kt
class User {
    var name: String
        get() = field
        set(value) {field = value}
}
```
#### 커스텀 접근자
```kt
val isSquare: Boolean
    get() {
        return height == width
    }
```

## 소스코드 구조
자바와 동일, package로 패키지 선언, 다른 패키지에서 사용하려면 import를 사용

## 선택 표현과 처리
### enum
```kt
enum class Color(
    val r: Int, val g: Int, val b: Int
) {
    RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255);  // 함수를 구현하려면 ;를 필수로 넣어야 한다.

    fun rgb() = (r * 256 + g) * 256 + b
}
```
when에서 enum으로 값을 체크할 때, 가능하면 문 보다 식으로 사용하여 실수를 컴파일 오류로 확인하도록 하자. (다만, 의도적인 경우도 있으니 섣불리 변경하지 말자.)
```kt
fun whenWithStatement(color: Color) {
    when(color) {
        Color.RED -> foo.handleRed()
        Color.GREEN -> foo.handleGreen()
        // 문으로 작성할 경우, Blue가 없으면 Warning이 발생한다. if문의 else가 없는 것 처럼.
    }
}

fun whenWithExpression(color: Color) = when(color) {
    Color.RED -> foo.handleRed()
    Color.GREEN -> foo.handleGreen()
    // 식으로 작성할 경우, 명확히 값이 리턴되야 하므로, Blue가 없으면 컴파일 에러가 발생한다.
}
```
enum과 유사한 [sealed class](https://velog.io/@cmplxn/Kotlin-ClassInner-Enum-Sealed)도 있다. (4장)

### when