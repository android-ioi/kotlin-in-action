# 3장. 함수 정의와 호출(1)
## 컬렉션 만들기
```kt
val list = arrayListOf(0, 1, 2)
val map = hashMapOf(1 to "Hello", 2 to "World") // to = Pair<Left, Right>
```

위의 list나 map은 Java 클래스로 사용되며, 코틀린은 자체 컬렉션 기능을 제공하지 않는다. (자바 코드와 상호 작용이 용이하기 때문)

하지만, 다양한 익스텐션으로 Java 보다 더 많은 기능을 쓸 수 있다. (ex> list.last())

## 함수를 호출하기 쉽게 만들기
### 이름 붙인 인자
* https://kotlinlang.org/docs/functions.html#named-arguments
```kt
fun <T> joinToString(
    collection: Collection<T>, 
    separator: String, 
    prefix: String,
    postfix: String): String
```
위와 같은 함수를 호출할 때, 코틀린은 좀 더 쉽게 호출할 수 있게 해준다.

```kt
joinToString(collection, separator = " ", prefix = " ", postfix = ".")
```
자바와는 다르게 파라미터에 이름을 붙일 수 있어서, 편의성을 높여준다. (Refactor를 통해 Rename을 할 경우, 같이 변경된다.)

### 디폴트 파라미터
```kt
fun <T> joinToString(
    collection: Collection<T>, 
    separator: String = ", ", 
    prefix: String = "",
    postfix: String = ""): String
```
C++, C# 등에서 제공하는 디폴트 파라미터를 코틀린에서도 제공한다. 코틀린에서 호출할 시, Named arguments를 활용하면 인자값이 모호한 상황이 발생하지 않는다.

```kt
joinToString(collection, postfix = ";", prefix = "# ") // # 1, 2, 3;
```
Java에서 사용하려면 @JvmOverloads 어노테이션을 활용하면 된다.

### 정적인 유틸리티 클래스 없애기 : 최상위 함수와 프로퍼티
#### 최상위 함수
자바에서 흔히 사용하는 패턴인 Utility 클래스는 일반적으로 프로그램 전체에 사용되거나, 어느 한 클래스에 속하기 어려워서 static 클래스로 만들기 마련인데,코틀린은 클래스 밖에 최상위 함수를 만들어 사용하면 된다.

```kt
// Join.kt
package strings

fun joinToString(...) : String { ... }
```
자바에서는 JoinKt를 통해 호출할 수 있으며,
```java
import strings.JoinKt;
...
JoinKt.joinToString(list, ", ", "", "")
```
@JvmName으로 파일에 대응하는 클래스명을 변경할 수 있다.
```kt
@file:JvmName("StringFunctions")
package strings

fun joinToString(...) : String { ... }
```
```java
import strings.StringFunctions;
...
StringFunctions.joinToString(list, ", ", "", "")
```
코틀린의 유틸리티는 최상위 함수와 이후에 언급할 확장 함수를 활용하여 사용하면 편하다. (https://deep-dive-dev.tistory.com/43)

#### 최상위 프로퍼티
함수와 동일하게 프로퍼티도 최상위 수준에 놓을 수 있다. 일반적인 프로퍼티와 동일하게 getter, setter가 생성된다.

### top-level function/property
(경준) 최상위 함수와 최상위 프로퍼티의 경우, 코드가 다소 혼란스러워질 수 있으므로 주의해야 한다. Java의 static import와 유사하게, 코드 스니핏만 보고 해당 함수나 프로퍼티가 어떤 파일 (혹은 클래스)에 있는지 한번에 알기 어렵다.

`최상위 함수`는 확장 함수를 통한 유틸리티에 사용하고, `최상위 프로퍼티`는 상수만 사용하고 const 키워드 등을 통해 제한적으로만 사용하는 것이 좋을 것 같다.

코딩 컨벤션 등으로 제한해두는 것도 좋다.
* https://kotlinlang.org/docs/coding-conventions.html
* https://wnsgml972.github.io/kotlin/2020/11/28/kotlin-coding-convention/

> 최상위 함수의 좋은 사용법에 또 다른 케이스가 있을까?

## 메소드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티
```kt
fun String.lastChar(): Char = this.get(this.length - 1)
```
자바로 컴파일 되면, 리시버 객체가 파라미터로 들어간다. (자바에서 사용할 경우도 동일)
```java
public static final char lastChar(@NotNull String $this$lastChar) {
    Intrinsics.checkNotNullParameter($this$lastChar, "$this$lastChar");
    return $this$lastChar.charAt($this$lastChar.length() - 1);
}
```

### 임포트와 확장 함수
```kt
import strings.lastChar as last

val c = "Kotlin".last() // lastChar -> last
```

확장 함수는 코틀린 문법상 반드시 짧은 이름을 써야하기에, 확장 함수 충돌을 위해 위와 같은 방법을 사용한다.

-> Q. 반드시 짧은 이름을 써야 하는 이유는?

### Java에서의 호출
```java
char c = StringUtilKt.lastChar("Java"); // 리시버 객체를 파라미터로 넣는다.
```

### 확장 함수로 유틸리티 함수 정의
```kt
fun <T> Collection<T>.joinToString( ... ) { ... }
```

### 확장 함수는 오버라이드 할 수 없다
확장 함수는 정적 메소드이며, 자바로 컴파일 되면 static 메소드로 컴파일 된다. 따라서 오버라이드 할 수 없다.

```kt
fun View.showOff() = println("View!")
fun Button.showOff() = println("Button!")

val view : View = Button()
view.showOff()
>> View!
```

> 확장 함수와 클래스 멤버 함수의 이름과 시그니쳐가 같다면, 클래스의 멤버 함수가 호출된다.

### 확장 프로퍼티
프로퍼티라고 불리기는 하지만, 기존 클래스의 인스턴스 객체에 필드를 추가할 방법은 없다. (다만, 프로퍼티 문법으로 더 짧은 코드를 작성할 수 있다.)
```kt
val String.lastChar: Char
    get() = get(length - 1)
```

자바로 컴파일 할 경우, 확장 함수와 크게 다르지 않다.
```java
public static final char getLastChar(@NotNull String $this$lastChar) {
    Intrinsics.checkNotNullParameter($this$lastChar, "$this$lastChar");
    return $this$lastChar.charAt($this$lastChar.length() - 1);
}
```
변경 가능한 확장 프로퍼티 선언도 가능하다. [Backing field](../%232/2.%20Basic%20kotlin.md#backing-field)가 없어서 최소한의 getter를 만들어야 한다.
```kt
var StringBuilder.lastChar: Char
    get() = get(length - 1)
    set(value: Char) {
        this.setCharAt(length - 1, value)
    }
```
자바에서의 사용은 확장 함수와 유사하나 프로퍼티의 특성(getter/setter)을 갖는다.
```java
char c = StringUtilKt.getLastChar("Java");
```